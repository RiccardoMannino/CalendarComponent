{"ast":null,"code":"/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/\nimport { __assign } from 'tslib';\nimport { identity, createPlugin, requestJson, addDays } from '@fullcalendar/common';\n\n// rename this file to options.ts like other packages?\nvar OPTION_REFINERS = {\n  googleCalendarApiKey: String\n};\nvar EVENT_SOURCE_REFINERS = {\n  googleCalendarApiKey: String,\n  googleCalendarId: String,\n  googleCalendarApiBase: String,\n  extraParams: identity\n};\n\n// TODO: expose somehow\nvar API_BASE = 'https://www.googleapis.com/calendar/v3/calendars';\nvar eventSourceDef = {\n  parseMeta: function (refined) {\n    var googleCalendarId = refined.googleCalendarId;\n    if (!googleCalendarId && refined.url) {\n      googleCalendarId = parseGoogleCalendarId(refined.url);\n    }\n    if (googleCalendarId) {\n      return {\n        googleCalendarId: googleCalendarId,\n        googleCalendarApiKey: refined.googleCalendarApiKey,\n        googleCalendarApiBase: refined.googleCalendarApiBase,\n        extraParams: refined.extraParams\n      };\n    }\n    return null;\n  },\n  fetch: function (arg, onSuccess, onFailure) {\n    var _a = arg.context,\n      dateEnv = _a.dateEnv,\n      options = _a.options;\n    var meta = arg.eventSource.meta;\n    var apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;\n    if (!apiKey) {\n      onFailure({\n        message: 'Specify a googleCalendarApiKey. See http://fullcalendar.io/docs/google_calendar/'\n      });\n    } else {\n      var url = buildUrl(meta);\n      // TODO: make DRY with json-feed-event-source\n      var extraParams = meta.extraParams;\n      var extraParamsObj = typeof extraParams === 'function' ? extraParams() : extraParams;\n      var requestParams_1 = buildRequestParams(arg.range, apiKey, extraParamsObj, dateEnv);\n      requestJson('GET', url, requestParams_1, function (body, xhr) {\n        if (body.error) {\n          onFailure({\n            message: 'Google Calendar API: ' + body.error.message,\n            errors: body.error.errors,\n            xhr: xhr\n          });\n        } else {\n          onSuccess({\n            rawEvents: gcalItemsToRawEventDefs(body.items, requestParams_1.timeZone),\n            xhr: xhr\n          });\n        }\n      }, function (message, xhr) {\n        onFailure({\n          message: message,\n          xhr: xhr\n        });\n      });\n    }\n  }\n};\nfunction parseGoogleCalendarId(url) {\n  var match;\n  // detect if the ID was specified as a single string.\n  // will match calendars like \"asdf1234@calendar.google.com\" in addition to person email calendars.\n  if (/^[^/]+@([^/.]+\\.)*(google|googlemail|gmail)\\.com$/.test(url)) {\n    return url;\n  }\n  if ((match = /^https:\\/\\/www.googleapis.com\\/calendar\\/v3\\/calendars\\/([^/]*)/.exec(url)) || (match = /^https?:\\/\\/www.google.com\\/calendar\\/feeds\\/([^/]*)/.exec(url))) {\n    return decodeURIComponent(match[1]);\n  }\n  return null;\n}\nfunction buildUrl(meta) {\n  var apiBase = meta.googleCalendarApiBase;\n  if (!apiBase) {\n    apiBase = API_BASE;\n  }\n  return apiBase + '/' + encodeURIComponent(meta.googleCalendarId) + '/events';\n}\nfunction buildRequestParams(range, apiKey, extraParams, dateEnv) {\n  var params;\n  var startStr;\n  var endStr;\n  if (dateEnv.canComputeOffset) {\n    // strings will naturally have offsets, which GCal needs\n    startStr = dateEnv.formatIso(range.start);\n    endStr = dateEnv.formatIso(range.end);\n  } else {\n    // when timezone isn't known, we don't know what the UTC offset should be, so ask for +/- 1 day\n    // from the UTC day-start to guarantee we're getting all the events\n    // (start/end will be UTC-coerced dates, so toISOString is okay)\n    startStr = addDays(range.start, -1).toISOString();\n    endStr = addDays(range.end, 1).toISOString();\n  }\n  params = __assign(__assign({}, extraParams || {}), {\n    key: apiKey,\n    timeMin: startStr,\n    timeMax: endStr,\n    singleEvents: true,\n    maxResults: 9999\n  });\n  if (dateEnv.timeZone !== 'local') {\n    params.timeZone = dateEnv.timeZone;\n  }\n  return params;\n}\nfunction gcalItemsToRawEventDefs(items, gcalTimezone) {\n  return items.map(function (item) {\n    return gcalItemToRawEventDef(item, gcalTimezone);\n  });\n}\nfunction gcalItemToRawEventDef(item, gcalTimezone) {\n  var url = item.htmlLink || null;\n  // make the URLs for each event show times in the correct timezone\n  if (url && gcalTimezone) {\n    url = injectQsComponent(url, 'ctz=' + gcalTimezone);\n  }\n  return {\n    id: item.id,\n    title: item.summary,\n    start: item.start.dateTime || item.start.date,\n    end: item.end.dateTime || item.end.date,\n    url: url,\n    location: item.location,\n    description: item.description,\n    attachments: item.attachments || [],\n    extendedProps: (item.extendedProperties || {}).shared || {}\n  };\n}\n// Injects a string like \"arg=value\" into the querystring of a URL\n// TODO: move to a general util file?\nfunction injectQsComponent(url, component) {\n  // inject it after the querystring but before the fragment\n  return url.replace(/(\\?.*?)?(#|$)/, function (whole, qs, hash) {\n    return (qs ? qs + '&' : '?') + component + hash;\n  });\n}\nvar main = createPlugin({\n  eventSourceDefs: [eventSourceDef],\n  optionRefiners: OPTION_REFINERS,\n  eventSourceRefiners: EVENT_SOURCE_REFINERS\n});\nexport default main;","map":{"version":3,"mappings":"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","names":["OPTION_REFINERS","googleCalendarApiKey","String","EVENT_SOURCE_REFINERS","googleCalendarId","googleCalendarApiBase","extraParams","identity","API_BASE","eventSourceDef","parseMeta","refined","url","parseGoogleCalendarId","fetch","arg","onSuccess","onFailure","context","dateEnv","options","meta","eventSource","apiKey","message","buildUrl","extraParamsObj","requestParams_1","buildRequestParams","range","requestJson","body","xhr","error","errors","rawEvents","gcalItemsToRawEventDefs","items","timeZone","match","test","exec","decodeURIComponent","apiBase","encodeURIComponent","params","startStr","endStr","canComputeOffset","formatIso","start","end","addDays","toISOString","key","timeMin","timeMax","singleEvents","maxResults","gcalTimezone","map","item","gcalItemToRawEventDef","htmlLink","injectQsComponent","id","title","summary","dateTime","date","location","description","attachments","extendedProps","extendedProperties","shared","component","replace","whole","qs","hash","createPlugin","eventSourceDefs","optionRefiners","eventSourceRefiners"],"sources":["C:\\Users\\ruggi\\Desktop\\React\\CmpCalendar\\node_modules\\@fullcalendar\\google-calendar\\src\\options-refiners.ts","C:\\Users\\ruggi\\Desktop\\React\\CmpCalendar\\node_modules\\@fullcalendar\\google-calendar\\src\\event-source-refiners.ts","C:\\Users\\ruggi\\Desktop\\React\\CmpCalendar\\node_modules\\@fullcalendar\\google-calendar\\src\\main.ts"],"sourcesContent":["// rename this file to options.ts like other packages?\n\nexport const OPTION_REFINERS = {\n  googleCalendarApiKey: String,\n}\n","import { identity, Identity, Dictionary } from '@fullcalendar/common'\n\nexport const EVENT_SOURCE_REFINERS = {\n  googleCalendarApiKey: String, // TODO: rename with no prefix?\n  googleCalendarId: String,\n  googleCalendarApiBase: String,\n  extraParams: identity as Identity<Dictionary | (() => Dictionary)>,\n}\n","import { createPlugin, EventSourceDef, addDays, DateEnv, requestJson, Dictionary } from '@fullcalendar/common'\nimport { OPTION_REFINERS } from './options-refiners'\nimport './options-declare'\nimport { EVENT_SOURCE_REFINERS } from './event-source-refiners'\nimport './event-source-declare'\n\n// TODO: expose somehow\nconst API_BASE = 'https://www.googleapis.com/calendar/v3/calendars'\n\ninterface GCalMeta {\n  googleCalendarId: string\n  googleCalendarApiKey?: string\n  googleCalendarApiBase?: string,\n  extraParams?: Dictionary | (() => Dictionary)\n}\n\nlet eventSourceDef: EventSourceDef<GCalMeta> = {\n\n  parseMeta(refined): GCalMeta | null {\n    let { googleCalendarId } = refined\n\n    if (!googleCalendarId && refined.url) {\n      googleCalendarId = parseGoogleCalendarId(refined.url)\n    }\n\n    if (googleCalendarId) {\n      return {\n        googleCalendarId,\n        googleCalendarApiKey: refined.googleCalendarApiKey,\n        googleCalendarApiBase: refined.googleCalendarApiBase,\n        extraParams: refined.extraParams,\n      }\n    }\n\n    return null\n  },\n\n  fetch(arg, onSuccess, onFailure) {\n    let { dateEnv, options } = arg.context\n    let meta: GCalMeta = arg.eventSource.meta\n    let apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey\n\n    if (!apiKey) {\n      onFailure({\n        message: 'Specify a googleCalendarApiKey. See http://fullcalendar.io/docs/google_calendar/',\n      })\n    } else {\n      let url = buildUrl(meta)\n\n      // TODO: make DRY with json-feed-event-source\n      let { extraParams } = meta\n      let extraParamsObj = typeof extraParams === 'function' ? extraParams() : extraParams\n\n      let requestParams = buildRequestParams(\n        arg.range,\n        apiKey,\n        extraParamsObj,\n        dateEnv,\n      )\n\n      requestJson('GET', url, requestParams, (body, xhr) => {\n        if (body.error) {\n          onFailure({\n            message: 'Google Calendar API: ' + body.error.message,\n            errors: body.error.errors,\n            xhr,\n          })\n        } else {\n          onSuccess({\n            rawEvents: gcalItemsToRawEventDefs(\n              body.items,\n              requestParams.timeZone,\n            ),\n            xhr,\n          })\n        }\n      }, (message, xhr) => {\n        onFailure({ message, xhr })\n      })\n    }\n  },\n}\n\nfunction parseGoogleCalendarId(url) {\n  let match\n\n  // detect if the ID was specified as a single string.\n  // will match calendars like \"asdf1234@calendar.google.com\" in addition to person email calendars.\n  if (/^[^/]+@([^/.]+\\.)*(google|googlemail|gmail)\\.com$/.test(url)) {\n    return url\n  }\n\n  if (\n    (match = /^https:\\/\\/www.googleapis.com\\/calendar\\/v3\\/calendars\\/([^/]*)/.exec(url)) ||\n    (match = /^https?:\\/\\/www.google.com\\/calendar\\/feeds\\/([^/]*)/.exec(url))\n  ) {\n    return decodeURIComponent(match[1])\n  }\n\n  return null\n}\n\nfunction buildUrl(meta) {\n  let apiBase = meta.googleCalendarApiBase\n  if (!apiBase) {\n    apiBase = API_BASE\n  }\n  return apiBase + '/' + encodeURIComponent(meta.googleCalendarId) + '/events'\n}\n\nfunction buildRequestParams(range, apiKey: string, extraParams: Dictionary, dateEnv: DateEnv) {\n  let params\n  let startStr\n  let endStr\n\n  if (dateEnv.canComputeOffset) {\n    // strings will naturally have offsets, which GCal needs\n    startStr = dateEnv.formatIso(range.start)\n    endStr = dateEnv.formatIso(range.end)\n  } else {\n    // when timezone isn't known, we don't know what the UTC offset should be, so ask for +/- 1 day\n    // from the UTC day-start to guarantee we're getting all the events\n    // (start/end will be UTC-coerced dates, so toISOString is okay)\n    startStr = addDays(range.start, -1).toISOString()\n    endStr = addDays(range.end, 1).toISOString()\n  }\n\n  params = {\n    ...(extraParams || {}),\n    key: apiKey,\n    timeMin: startStr,\n    timeMax: endStr,\n    singleEvents: true,\n    maxResults: 9999,\n  }\n\n  if (dateEnv.timeZone !== 'local') {\n    params.timeZone = dateEnv.timeZone\n  }\n\n  return params\n}\n\nfunction gcalItemsToRawEventDefs(items, gcalTimezone) {\n  return items.map((item) => gcalItemToRawEventDef(item, gcalTimezone))\n}\n\nfunction gcalItemToRawEventDef(item, gcalTimezone) {\n  let url = item.htmlLink || null\n\n  // make the URLs for each event show times in the correct timezone\n  if (url && gcalTimezone) {\n    url = injectQsComponent(url, 'ctz=' + gcalTimezone)\n  }\n\n  return {\n    id: item.id,\n    title: item.summary,\n    start: item.start.dateTime || item.start.date, // try timed. will fall back to all-day\n    end: item.end.dateTime || item.end.date, // same\n    url,\n    location: item.location,\n    description: item.description,\n    attachments: item.attachments || [],\n    extendedProps: (item.extendedProperties || {}).shared || {},\n  }\n}\n\n// Injects a string like \"arg=value\" into the querystring of a URL\n// TODO: move to a general util file?\nfunction injectQsComponent(url, component) {\n  // inject it after the querystring but before the fragment\n  return url.replace(\n    /(\\?.*?)?(#|$)/,\n    (whole, qs, hash) => (qs ? qs + '&' : '?') + component + hash,\n  )\n}\n\nexport default createPlugin({\n  eventSourceDefs: [eventSourceDef],\n  optionRefiners: OPTION_REFINERS,\n  eventSourceRefiners: EVENT_SOURCE_REFINERS,\n})\n"]},"metadata":{},"sourceType":"module"}